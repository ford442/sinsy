<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Sinsy</title>
  </head>
  <body>
    <div style="display:flex; gap:1rem; align-items:center; margin-bottom:.5rem;">
      <div>
        <strong>Voice (server)</strong><br>
        <select id="voice-list" style="min-width:420px"></select>
        <button id="reload-voices">Refresh</button>
        <div style="margin-top:.3rem;">or upload a local voice: <input id="voice-file" type="file" accept=".htsvoice"/></div>
      </div>
      <div>
        <strong>Song (server)</strong><br>
        <select id="mxl-list" style="min-width:420px"></select>
        <button id="reload-mxls">Refresh</button>
        <div style="margin-top:.3rem;">or upload a local MusicXML: <input id="mxl-file" type="file" accept=".mxl,.xml"/></div>
      </div>
    </div>
    <p style="color: #444; max-width: 80ch;">Tip: select server entries (from the directories /voices and /scores) or choose a local file. Server lists are fetched dynamically. Local file uploads are written directly into the in-memory Emscripten FS and used for synthesis.</p>
    <button id="run-button" disabled>Synthesize</button>
    <div id="output"></div>
    <script>
      const runButton = document.getElementById('run-button');
      const outputElement = document.getElementById('output');

      var Module = {
        // Ensure data and wasm files are loaded from the same directory
        locateFile: function(path) { return './' + path; },
        onRuntimeInitialized: function() {
          console.log('Sinsy loaded');
          runButton.disabled = false;
        },
        print: function(text) {
          console.log(text);
        },
        printErr: function(text) {
          console.error(text);
        }
      };
runButton.addEventListener('click', async () => {
        // selection/upload elements
        const selectedVoice = document.getElementById('voice-list').value;
        const selectedMxl = document.getElementById('mxl-list').value;
        const localVoiceFile = document.getElementById('voice-file').files[0];
        const localMxlFile = document.getElementById('mxl-file').files[0];

        // make sure directories exist in WASM FS
        try { Module.FS.mkdir('/voices'); } catch (e) {}
        try { Module.FS.mkdir('/scores'); } catch (e) {}

        // helper: fetch remote URL into FS
        async function fetchToFS(url, destPath) {
          outputElement.textContent = `Fetching ${url} ...`;
          const res = await fetch(url);
          if (!res.ok) throw new Error(`HTTP ${res.status} when fetching ${url}`);
          const data = new Uint8Array(await res.arrayBuffer());
          // write or overwrite
          try { Module.FS.unlink(destPath); } catch (_) {}
          Module.FS.writeFile(destPath, data);
          outputElement.textContent = `Wrote ${destPath} (${data.length} bytes)`;
        }

        try {
          let voicePath, mxlPath;

          // handle voice: uploaded file wins, otherwise selected server file
          if (localVoiceFile) {
            const data = new Uint8Array(await localVoiceFile.arrayBuffer());
            try { Module.FS.unlink('/voices/voice_uploaded.htsvoice'); } catch (_) {}
            Module.FS.writeFile('/voices/voice_uploaded.htsvoice', data);
            outputElement.textContent = `Wrote /voices/voice_uploaded.htsvoice (${data.length} bytes)`;
            voicePath = '/voices/voice_uploaded.htsvoice';
          } else if (selectedVoice) {
            await fetchToFS(selectedVoice, '/voices/voice.htsvoice');
            voicePath = '/voices/voice.htsvoice';
          } else {
            throw new Error('No voice selected or uploaded');
          }

          // handle musicxml: uploaded file wins, otherwise selected server file
          if (localMxlFile) {
            const data = new Uint8Array(await localMxlFile.arrayBuffer());
            try { Module.FS.unlink('/scores/score_uploaded.mxl'); } catch (_) {}
            Module.FS.writeFile('/scores/score_uploaded.mxl', data);
            outputElement.textContent = `Wrote /scores/score_uploaded.mxl (${data.length} bytes)`;
            mxlPath = '/scores/score_uploaded.mxl';
          } else if (selectedMxl) {
            await fetchToFS(selectedMxl, '/scores/score.mxl');
            mxlPath = '/scores/score.mxl';
          } else {
            throw new Error('No song selected or uploaded');
          }

          const args = ['-x', '/dic', '-m', voicePath, '-o', 'output.wav', mxlPath];

          // It is good practice to check the return value (0 = success)
          const returnCode = Module.callMain(args);

        if (returnCode === 0) {
            try {
              const wavData = Module.FS.readFile('output.wav');
              const blob = new Blob([wavData], { type: 'audio/wav' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = 'output.wav';
              a.textContent = 'Download output.wav';
              outputElement.innerHTML = '';
              outputElement.appendChild(a);
            } catch (e) {
              console.error(e);
              outputElement.textContent = 'Error reading output file.';
            }
        } else {
            outputElement.textContent = 'Synthesis failed. Check console for details.';
        }
        } catch (e) {
          console.error(e);
          outputElement.textContent = `Error: ${e.message}`;
        }
      });

      // --- Directory listing helpers ---
      async function fetchDirEntries(url) {
        try {
          const res = await fetch(url);
          if (!res.ok) return [];
          const txt = await res.text();
          // pull hrefs (works with typical directory HTML)
          const re = /href\s*=\s*"([^"]+)"/gi;
          const entries = [];
          let m;
          while ((m = re.exec(txt)) !== null) {
            let href = m[1];
            if (href === '../' || href === '/') continue;
            if (href.endsWith('/')) continue; // skip directories
            entries.push(href);
          }
          return entries;
        } catch (e) {
          console.warn('fetchDirEntries failed', e);
          return [];
        }
      }

      async function populateLists() {
        const voiceSel = document.getElementById('voice-list');
        const mxlSel = document.getElementById('mxl-list');

        // reset
        voiceSel.innerHTML = '<option value="">-- choose a voice from server --</option>';
        mxlSel.innerHTML = '<option value="">-- choose a song from server --</option>';

        const voices = await fetchDirEntries('./voices/');
        voices.filter(f => f.toLowerCase().endsWith('.htsvoice')).forEach(f => {
          const path = '/voices/' + f;
          const opt = document.createElement('option');
          opt.value = path;
          opt.textContent = f;
          voiceSel.appendChild(opt);
        });

        const mxls = await fetchDirEntries('./scores/');
        mxls.filter(f => f.toLowerCase().endsWith('.mxl') || f.toLowerCase().endsWith('.xml')).forEach(f => {
          const path = '/scores/' + f;
          const opt = document.createElement('option');
          opt.value = path;
          opt.textContent = f;
          mxlSel.appendChild(opt);
        });
      }

      document.getElementById('reload-voices').addEventListener('click', populateLists);
      document.getElementById('reload-mxls').addEventListener('click', populateLists);

      // initial populate
      populateLists();
    </script>
    <script src="sinsy.js"></script>
  </body>
</html>
